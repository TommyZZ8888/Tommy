juc

redis=》 22

mysql

jvm

austin流程



### redis

##### redis是什么？

redis是一种基于key-value存储的非关系型数据库；

支持多种数据结构 string（token，计数），hash（用户信息），list（列表），set（共同关注），zset（排行榜）

基于内存，而且是单线程，避免了线程切换，所以读写速度非常出色

redis还提供了键过期，事务（multi开启事务，exec执行），lua脚本等功能

redis还提供了将内存中的数据利用快照或日志保存到磁盘，防止断电后数据丢失



##### redis多路复用

以epoll为例：

将用户socket对应的id都注册到epoll中，然后epoll监听哪个socket上有消息到达，然后就处理哪个，充分利用资源



##### 持久化

rdb 和 aof

rdb：redis data base 是把当前进程中的数据生成快照存放到硬盘，以便重启时恢复数据

两种方式：手动 自动；；手动触发分为save命令 阻塞当前服务器，直到rdb完成，对于比较大的实例，可能会阻塞较长时间

bgsave，fork个子进程，在子进程中完成rdb，阻塞只在fork的一瞬间。

自动触发：shutdown如果没有开启aof会触发 ， save m n m秒内修改n次触发；



rdb是一个紧凑的二进制文件，数据恢复速度快，但由于间隔一段时间持久化，所以可能会损失一段时间的数据。



aof（append only file），以独立日志的方式记录每次写命令，再次重启时重新执行命令以达到恢复数据的目的。

aof解决了数据持久化的实时性问题，但是文件较大，恢复数据速度慢。

流程：文件写入=》同步=》重写=》



选择：一般来说会选择混合的方式进行持久化，如果可以容忍一段时间数据的丢失，可以选择rdb

全量的rdb和增量的aof日志文件。



##### 高可用

主从复制，哨兵，集群

主从复制：数据冗余，故障恢复，负载均衡，高可用基石

一主一从；故障转移

一主多从：读写分离

问题：一旦主节点出现故障，需要手动将从节点升级为主节点



##### 哨兵

作用：监控，自动故障转移，配置提供者，通知

主观下线和客观下线：主观：每个sentinel每秒会向其他主节点，从节点，sentinel节点发送ping命令，如果超过规定的时间没有回复，则认为失败下线

客观：当下线的是主节点时，从节点会向其他从节点发送命令询问，如果多数从节点都判断主节点下线，那就做出客观下线的决定



故障转移流程：

1.选举出一个主节点

2.执行命令slaveof no one让其成为主节点

3.主节点向剩余的从节点发送命令，让其成为新主节点的从节点

4.将原来的主节点更新为从节点，待其故障恢复后，复制新的主节点



sentinel选举：每个在线的sentinel节点都有资格成为领导者，当他确定主节点下线时，会向其他sentinel节点发送命令，如果其他sentinel没有同意

其他sentinel节点，就不会拒绝，如果得到票数大于规定票数，那么他会成为领导者，否则进入下一次选举。



新节点：过滤不健康的节点（主观下线，断线），，选择从节点最高的从节点列表，存在返回不存在继续，，选择复制偏移量最大的从节点（数据最完整），，选择runid最小的从节点。



redis集群：解决高可用和分布式的问题

数据分区：节点取余分区，一致性hash分区，虚拟槽分区



##### 缓存

缓存击穿：key过期，直接访问数据库++++++++解决：加锁更新，把过期时间写进value，异步更新

缓存穿透：缓存数据库都不存在++++++++解决：缓存空值默认值；设置较短的过期时间，布隆过滤器

缓存雪崩：同一时间大量的key过期，全部访问数据库++++++++解决：均匀的设置过期时间，集群，热点数据永不过期



缓存数据库一致性：

删除缓存还是更新缓存：删除缓存++删除缓存操作更快，redis以空间换时间，更新缓存可能一段时间用不到，造成一段时间的数据冗余

先更新数据库还是先删除缓存：先更新数据库++更新数据库的操作设计锁行锁表操作，几乎不可能在删除缓存之前完成

消息队列：更新数据库后，发送消息到消息队列，待消费消息成功后，删除缓存

canal+mq，使用阿里的数据库监听中间件监听binlog变化，一旦数据修改，canal会自动发送消息到消息队列



布隆过滤器：是一个连续的数据结构，每个存储位存储一个bit位存储0或1，判断key是否存在即判断是否全是1



本地缓存和分布式缓存的一致性问题：本地缓存Caffeine，分布式缓存redis，，可以使用redis的发布订阅，，也可以使用消息队列



缓存预热：

1.写个接口，上线后手动更新

2.数据量不大的情况下，项目启动时更新

3.定时刷新



热key问题：热key通常大量的访问，首先监控，每次调用redis，对key进行记录

也可以使用命令查看每个key的调用次数 monitor命令

监控到之后：把热key打散到不同的服务器，加入二级缓存，每次先从二级缓存查询



热key重建：开发的时候一般使用“缓存+过期时间”的策略，既可以加速数据读写，又保证数据的定期更新，这种模式基本能够满足绝大部分需求

但是可能并发量大，涉及大量的计算，短时间重建不好

解决：1.互斥锁，只允许一个线程重建，，2.永不过期，对每个值设置一个过期值



无底洞问题：节点不断增加，性能反而下降

先分析一下无底洞问题：

- 客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。
- 网络连接数变多，对节点的性能也有一定影响。

常见的优化思路如下：

- 命令本身的优化，例如优化操作语句等。
- 减少网络通信次数。
- 降低接入成本，例如客户端使用长连/连接池、NIO等。



#####  redis运维

redis内存不足：修改配置文件的maxmemory，，集群部署

redis过期回收策略： 定时删除：创建key时，增加过期时间，，当过期key较多时，会占用大量的cpu

​									 惰性删除：查询key的时候进行检查，如果key一直没有被查询，那就永远不会删除

​									 定期删除：每隔一段时间对数据库做一次检查，删除过期的key，，由于不可能对所有的key做轮询，所以随机取一些key检查

redis使用惰性+定期：：先定期删除，由于随机取key，所以没有取到的key惰性删除



内存溢出/内存淘汰策略：

1. noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返 回客户端错误信息，此 时Redis只响应读操作。
2. volatile-lru：根据LRU算法删除设置了超时属性（expire）的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。（常用）



redis阻塞：

​	api或数据结构不合理，slowlog get(n) 命令找到慢查询，	

1）修改为低算法复杂度的命令，如hgetall改为hmget等，禁用keys、sort等命 令

2）调整大对象：缩减大对象数据或把大对象拆分为多个小对象，防止一次命令操作过多的数据

cpu饱和，集群



大key问题：value值过大，hash list set存储过多元素  导致客户端耗时增加，io操作占用cpu，主动删除 被动删除阻塞

解决：bigkeys命令以遍历的方式分析redis中所有的key，并返回每种数据类型top1的key



可删除，使用unlink方式异步删除

不可删除，压缩和拆分



##### redis应用

异步队列：pubish/subscribe

实现延迟队列：使用zset，设置时间戳作为score排序，再通过zrangebyscore查询。



redis事务：提供简单的事务 multi开启事务，exec提交。不支持回滚，回滚会增加很多工作



redis+lua

lua脚本在redis中是原子性的，执行过程中不会插入其他指令。减少网络开销



redis 管道 pipeline

nc指令 节省了rtt（round trip time）将多条命令一起打包，减少了客户端服务端调用次数，减少了上下文切换



redis分布式锁

setnx指令：问题：如果del指令执行异常出错，那么key永远不会释放，，v2：加过期时间，如果expire指令执行异常，那也永远不会释放

原因setnx 和 del指令不是一个原子性的：：解决方案 redission













### mysql

##### mvcc多版本并发控制

mvcc解决了脏读幻读不可重复读的问题，保证了事务的隔离性，实现了数据的一致性读

mvcc实现依赖于隐藏字段（trx_id,roll_point），undolog实现了多版本，readview实现了并发控制



快照读：读取数据的历史版本，不加锁的普通select属于快照读，基于mvcc。

当前读：读取的是最新版本的数据，加锁的select，基于锁实现。



trxid每次修改一条记录时，会把该事务的事务id赋值给trxid

rollpoint，每次修改一条记录时，会把旧版本写入undolog日志中，这个隐藏列相当于一个指针。可以通过该隐藏列找到历史版本

readview是事务在使用mvcc机制进行快照读时产生的读视图

- 如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自己修改过的记录，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值小于ReadView中的up_limit_id值，表明生成该版本的事务在当前事务生成ReadView前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的trx_id属性值大于或等于ReadView中的low_limit_id值，表明生成该版本的事务在当前事务生成ReadView后才开启，所以该版本不可以被当前事务访问。
- 如果被访问版本的trx_id属性值在ReadView的up_limit_id和low_limit_id之间，那就需要判断一下trx_id属性值是不是在trx_ids列表中：
  `如果在，说明创建ReadView时生成该版本的事务还是活跃的，该版本不可以被访问。`
  `如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版本可以被访问。`

读已提交：每次查询都会生成readview

可重复读：只在第一次查询时生成readview

==mvcc流程==

首先获取事务自身的版本号，事务id————》获取事务的readview————》查询得到的事务id，与readview的规则进行比较————》不符合从undolog版本链中取出下一个版本的数据————》返回符合规则的数据









### 微服务

##### 概念

什么是微服务：是一种软件架构风格，将一个大型服务拆分成一个个小型的，自洽且松耦合的服务，每个服务负责特定的业务功能，并通过轻量级通信机制通讯。

每个微服务都可以独立运行部署。增加了灵活性，可伸缩性，可扩展性。

单体化--》服务化--》微服务：单体服务过大--》soa--》微服务，，soa是一种设计原则，微服务可以看作是soa的一种实践。



 问题：系统复杂，服务间通信开销，团队沟通，数据一致性，部署运维复杂



解决方案：dubbo，spring cloud alibaba， spring cloud netflix。

组件：N：enreka consul，springcloud config，feign，zuul gateway hystrix  A：nacos，nacos config，gateway，sentinel，skywalking



##### 注册中心

作用：服务注册（启动时注册到注册中心），服务发现（客户端向注册中心查询可用的服务实例，客户端选择合适的实例进行调用），负载均衡，故障恢复，服务治理

eureka ap consul cp zookeeper cp nacos ap/cp

enreka原理：服务启动后，将实例注册到注册中心，消费者可以查询服务实例列表获取可用的服务实例

服务实例会定期向注册中心server发送心跳，以表示存活，如果一段时间没有接收到服务实例的心跳，将会标记为不可用，踢出服务列表，下线

负载均衡：enreka在调用其他服务时，会从本地缓存中获取服务的注册信息，本地缓存没有，向eureka发送查询请求，获取可用服务实例，通过负载均衡算法选择其中一个调用



保证高可用： 多实例部署：将enreka实例部署在多个节点上，

服务注册消息的复制：当一个服务实例向eureka server注册时，每个eureka server实例都会复制其他实例的注册信息，以保持数据一致性

自我保护机制：当eureka server 节点一段时间没有收到心跳，自动进入自我保护机制，不再剔除注册表中的服务实例，防止网络抖动或其他原因造成的误剔除。



##### 配置中心

作用：对不同环境，不同实例或者在动态运行时实例需要调整和管理

配置中心：springcloud config，nacos consul apollo zookeeper

nacos配置中心原理：配置信息存储--》注册配置信息--》获取配置信息--》监听配置变化

nacos配置中心长轮询机制：客户端发起pull请求，服务端检查配置有没有变更，如果没有，设置一个定时任务，在一段时间后执行，并将客户端加入等待队列。

在等待期间，一旦配置信息发生变更，立即返回结果给客户端，，如果在等待期间，配置没有发生变更，则达到超时时间返回结果给客户端



##### 远程调用

http和rpc，http是应用层协议，主要强调网络通信，rpc是分布式系统之间通信的协议‘

feign基于http，dubbo基于rpc



feign是一个声明式的web服务客户端，简化了使用基于http的远程服务的开发

feign第一次调用耗时很长：主要原因是ribbon的懒加载机制，发生第一次调用时，feign会触发ribbon的加载过程，（从注册中心获取服务列表，建立连接池等操作），增加首次调用耗时

feign实现认证传递：使用拦截器传递认证信息，可以通过实现Requestrceptor接口来定义拦截器，将认证信息加到请求头，然后注册到feign的配置中。

package com.vren.weldingmonitoring_java.wave;

import com.alibaba.fastjson.JSONObject;
import com.vren.weldingmonitoring_java.socket.server.DeviceForShow;
import com.vren.weldingmonitoring_java.wave.domain.dto.EvaluationResult;
import com.vren.weldingmonitoring_java.wave.domain.dto.StepData;
import org.apache.commons.io.FileUtils;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.File;
import java.io.IOException;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.Collectors;

@Service
public class QualityEvaluationService {

    @Autowired
    private SaveServer saveServer;

    private boolean isStart = false;

    private final List<StepData> list = new ArrayList<>();

    private StepData inProcessOf;

    public void setForShowList(DeviceForShow deviceForShow) {
        if (inProcessOf != null) {
            this.inProcessOf.getList().add(deviceForShow);
        }
    }

    public void setInProcessOf(StepData stepData) {
        stepData.setList(new ArrayList<>());
        list.add(stepData);
        inProcessOf = stepData;
    }

    public boolean isStart() {
        return isStart;
    }

    public boolean start() {
        if (isStart) {
            return true;
        }
        isStart = true;
        return true;
    }

    public EvaluationResult stop() {
        EvaluationResult evaluationResult = new EvaluationResult();
        if (!isStart) {
            return evaluationResult;
        }
        isStart = false;
        File file = getFile();
        EvaluationResult recordResult = null;
        if (file.exists()) {
            try {
                String record = FileUtils.readFileToString(file, StandardCharsets.UTF_8);
                recordResult = JSONObject.parseObject(record, EvaluationResult.class);
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        List<StepData> stepDataList = new ArrayList<>(this.list);
        if (recordResult != null) {
            stepDataList.addAll(recordResult.getStepData());
        }
        for (StepData stepData : stepDataList) {
            List<DeviceForShow> list = stepData.getList();
            OptionalDouble optionalDouble = list.stream().mapToDouble(DeviceForShow::getU).average();
            if (optionalDouble.isEmpty()) {
                continue;
            }
            double average = optionalDouble.getAsDouble();
            double variance = list.stream().mapToDouble(item -> Math.pow(item.getU() - average, 2.0)).sum() / list.size();
            BigDecimal bigDecimal = new BigDecimal(variance);
            stepData.setVariance(bigDecimal.setScale(2, BigDecimal.ROUND_HALF_UP).doubleValue());
        }
        evaluationResult.setStepData(list);
        List<Double> variances = list.stream().map(StepData::getVariance).filter(Objects::nonNull).collect(Collectors.toList());
        evaluationResult.setVariances(variances);
        evaluationResult.setLevel(evaluate(variances));
        try {
            FileUtils.writeStringToFile(file, JSONObject.toJSONString(evaluationResult), StandardCharsets.UTF_8);
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            this.list.clear();
            this.inProcessOf = null;
        }
        return evaluationResult;
    }

    private File getFile() {
        String format = String.format("./data/%s/%s-%s/%s.%s", saveServer.getSn(), saveServer.getLayerNumber(), saveServer.getChannelNumber(), saveServer.getSn(), "json");
        return new File(format);
    }

    private int evaluate(List<Double> variances) {
        Map<Integer, List<Double>> collect = variances.stream().collect(Collectors.groupingBy(key -> {
            if (key <= 2) {
                return 1;
            }
            if (key > 2 && key <= 4) {
                return 2;
            }
            return 3;
        }, Collectors.toList()));
        //当所有段的方差在2（暂定）以内，判断为优
        if (collect.containsKey(1) && collect.get(1).size() == variances.size()) {
            return 1;
        }
        //当1-5段的方差在2-4以内，判断为良
        if (collect.containsKey(2) && collect.get(2).size() < 5) {
            return 2;
        }
        return 3;
    }

}

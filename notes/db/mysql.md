# MySql

###  1、InnoDB

**InnoDB**是一个将表中数据存储到磁盘上的存储引擎，所以即使关机后重启我们的数据还是存在的，而真正处理数据的过程是发生在内存中的，所以需要把磁盘中的数据加载到内存中，如果是处理写入或修改请求的话，还需要把内存中的内容刷新到磁盘上。



**字符集和比较规则**

- ASCII字符集：共收录128个字符，包含空格，标点符号，数字，大小写字母

- ISO 8895-1字符集：共收录256个字符

- GB2312字符集：收录了汉字以及拉丁字母，希腊字母等，其中收录汉字6763个，其他文字符号682个，其中这种字符集兼容ASCII字符集。

- GBK字符集：只是在GB2312字符集上进行扩充，编码规则向上兼容GB2312字符集

- utf8字符集：收录地球上能想到的所有字符。

  

  - `utf8mb3`：阉割过的`utf8`字符集，只使用1～3个字节表示字符。
  - `utf8mb4`：正宗的`utf8`字符集，使用1～4个字节表示字符。

  | 字符集名称 | Maxlen |
  | ---------- | ------ |
  | `ascii`    | `1`    |
  | `latin1`   | `1`    |
  | `gb2312`   | `2`    |
  | `gbk`      | `2`    |
  | `utf8`     | `3`    |
  | `utf8mb4`  | `4`    |

- 名称后缀意味着该比较规则是否区分语言中的重音、大小写什么的，具体可以用的值如下：

| 后缀   | 英文释义             | 描述             |
| ------ | -------------------- | ---------------- |
| `_ai`  | `accent insensitive` | 不区分重音       |
| `_as`  | `accent sensitive`   | 区分重音         |
| `_ci`  | `case insensitive`   | 不区分大小写     |
| `_cs`  | `case sensitive`     | 区分大小写       |
| `_bin` | `binary`             | 以二进制方式比较 |







**innoDB数据页**

innoDB都是以页为单位存放数据，每页大小为16kb。

innoDB始终会维护一条记录的单链表，链表中的各个节点是按照主键值由小到大的顺序连接起来的。

一个数据页大概分为7部分：

- `File Header`，表示页的一些通用信息，占固定的38字节。
- `Page Header`，表示数据页专有的一些信息，占固定的56个字节。
- `Infimum + Supremum`，两个虚拟的伪记录，分别表示页中的最小和最大记录，占固定的`26`个字节。
- `User Records`：真实存储我们插入的记录的部分，大小不固定。
- `Free Space`：页中尚未使用的部分，大小不确定。
- `Page Directory`：页中的某些记录相对位置，也就是各个槽在页面中的地址偏移量，大小不固定，插入的记录越多，这个部分占用的空间越多。
- `File Trailer`：用于检验页是否完整的部分，占用固定的8个字节。



innoDB的分组：对于最小记录所在的分组只能有1条记录，最大记录所在的分组拥有的记录条数只能在1-8条之间，剩下的分组中记录的条数范围只能在4-8条之间。`InnoDB`会为把页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个`槽`，存放在`Page Directory`中。

所以在一个数据页中查找指定主键的记录分为两步：

​    1、通过二分法确定该记录所在的槽，并找到该槽中主键值最小的那条记录。

​	2、通过记录的next_record属性遍历该槽所在的组中的各个记录。



**B+树**

在对页中的记录进行增删改查操作过程中，，我们必须通过一些诸如记录移动的操作来始终保证 **下一个数据页中用户记录的主键必须大于上一个数据页中用户记录的主键值**  这个过程叫做页分裂

B+树本身就是一个目录，或者说本身就是一个索引。

**索引**

==innoDB引擎会自动为我们创建聚簇索引，在innoDB存储引擎中，聚簇索引就是数据的存储方式，索引即数据，数据即索引==。

- 聚簇索引：

   1、使用主键值的大小进行记录和页的排序

   2、B+树的叶子节点存储的是完整的用户数据

- 非聚簇索引

   回表：根据以c2列大小排序的B+树来确定要查找的主键值，然后根据查找到的主键值在聚簇索引中查找一下完整的用户记录。

  

  1. `B+`树索引在空间和时间上都有代价，所以没事儿别瞎建索引。
  2. `B+`树索引适用于下面这些情况：
     - 全值匹配
     - 匹配左边的列
     - 匹配范围值
     - 精确匹配某一列并范围匹配另外一列
     - 用于排序
     - 用于分组
  3. 在使用索引时需要注意下面这些事项：
     - 只为用于搜索、排序或分组的列创建索引
     - 为列的基数大的列创建索引
     - 索引列的类型尽量小
     - 可以只对字符串值的前缀建立索引
     - 只有索引列在比较表达式中单独出现才可以适用索引
     - 为了尽可能少的让`聚簇索引`发生页面分裂和记录移位的情况，建议让主键拥有`AUTO_INCREMENT`属性。
     - 定位并删除表中的重复和冗余索引
     - 尽量使用`覆盖索引`进行查询，避免`回表`

  

**MySql数据结构的类型**



单表访问效率

| 访问效率    | 访问方式                                                     |
| ----------- | ------------------------------------------------------------ |
| const       | 主键索引，唯一二级索引                                       |
| ref         | 普通二级索引                                                 |
| ref_or_null | 二级索引列的值和该列的null值                                 |
| range       | 搜索条件复杂（WHERE key2 IN (1438, 6328) OR (key2 >= 38 AND key2 <= 79） |
| index       | 遍历二级索引记录的执行方式（SELECT key_part1, key_part2, key_part3 FROM single_table WHERE key_part2 = 'abc';）  1-2-3是联合索引，2是唯一索引 |
| all         | 全表扫描                                                     |

**一般情况下执行一个查询只会用到单个二级索引**





**InnoDB表空间**

 InnoDB是以页为单位管理存储空间的，为了更好的管理页，提出了区的概念，，对于16kb的页来说，连续的64个页就是一个区，每26个区划分成一组。

当数据足够多时，B+树的叶子节点和非叶子节点被区别对待，，存放叶子节点的区的集合算是一个段，存放非叶子节点的区的集合也算是一个段。也就是说一个索引会生成两个段，一个叶子节点段，一个非叶子节点段。









### 面试点

##### 1、update会锁表吗

 A:实际例子：

1.没有索引

运行命令：begin;开启事务，然后运行命令：update tb_user set phone=11 where name="c1";修改，先别commit事务。

再开一个窗口，直接运行命令：update tb_user set phone=22 where name="c2";会发现命令卡住了，但是当前面一个事务通过commit提交了，命令就会正常运行结束，说明是被锁表了。

2.给name字段加索引

create index index_name on tb_user(name);

然后继续如1里面的操作，也就是一个开启事务，运行update tb_user set phone=11 where name="c1"；先不提交

然后另一个运行update tb_user set phone=22 where name="c2";发现命令不会卡住，说明没有锁表

但是如果另一个也是update tb_user set phone=22 where name="c1";更新同一行，说明是锁行了

3.总结

如果没有索引，所以update会锁表，如果加了索引，就会锁行

